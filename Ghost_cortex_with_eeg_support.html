
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Holonomic Neural Cortex Visualizer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* --- Base Setup --- */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background-color: #000;
            font-family: 'Courier New', monospace;
            color: #00ffaa;
        }

        /* --- Layout Layers --- */
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1; /* Background layer */
        }

        #ui-overlay {
            position: relative; /* Sits on top */
            z-index: 2; /* Foreground layer */
            pointer-events: none; /* Allows mouse interaction with canvas */
        }

        /* --- UI Components --- */
        #controls, #info, #title {
            position: absolute;
            pointer-events: auto; /* Re-enable pointer events for UI */
            background: rgba(0, 20, 40, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid #00ffaa;
            border-radius: 15px;
            padding: 20px;
        }

        #controls {
            top: 20px;
            left: 20px;
            box-shadow: 0 0 30px rgba(0, 255, 170, 0.3);
            min-width: 320px;
        }
        
        #title {
            top: 20px;
            right: 20px;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 20px rgba(0, 255, 170, 0.8);
            letter-spacing: 2px;
            text-align: right;
            background: none;
            border: none;
            backdrop-filter: none;
        }
        
        #info {
            bottom: 20px;
            right: 20px;
            box-shadow: 0 0 20px rgba(0, 255, 170, 0.2);
        }

        /* --- UI Styling --- */
        .control-group { margin-bottom: 15px; }
        .control-group label { display: block; margin-bottom: 5px; font-size: 12px; text-transform: uppercase; letter-spacing: 1px; }
        .file-input-wrapper { margin-bottom: 15px; }
        .file-input { width: 100%; padding: 10px; background: rgba(0, 0, 0, 0.5); border: 2px dashed #00ffaa; color: #00ffaa; border-radius: 8px; text-align: center; cursor: pointer; transition: all 0.3s; }
        .file-input:hover { background: rgba(0, 255, 170, 0.1); }
        input[type="range"] { -webkit-appearance: none; appearance: none; width: 100%; height: 5px; background: #333; outline: none; border-radius: 5px; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 15px; height: 15px; background: #00ffaa; cursor: pointer; border-radius: 50%; box-shadow: 0 0 10px rgba(0, 255, 170, 0.7); }
        select { width: 100%; padding: 8px; background: rgba(0, 0, 0, 0.7); border: 1px solid #00ffaa; color: #00ffaa; border-radius: 5px; font-family: inherit; }
        button { background: linear-gradient(45deg, #00aa77, #00ffaa); border: none; color: black; padding: 10px 20px; border-radius: 8px; cursor: pointer; font-weight: bold; text-transform: uppercase; transition: all 0.3s ease; margin: 5px; }
        button:hover { box-shadow: 0 0 20px rgba(0, 255, 170, 0.8); transform: translateY(-2px); }
        .stats { font-size: 11px; margin: 2px 0; }
    </style>
</head>
<body>
    
    <div id="canvas-container"></div>

    <div id="ui-overlay">
        <div id="title">
            <div>NEURAL CORTEX PROJECTOR</div>
            <div id="subtitle" style="font-size: 14px; margin-top: 5px;">(Simulation Mode)</div>
        </div>
        <div id="controls">
            <h3 style="margin-bottom: 15px; text-align: center;">HOLONOMIC CONTROLS</h3>
            <div class="file-input-wrapper">
                <div class="file-input" onclick="document.getElementById('fileInput').click()">
                    <span id="fileInputLabel">ðŸ“‚ Load Real EEG File</span>
                </div>
                <input type="file" id="fileInput" style="display: none;" accept=".edf">
            </div>
             <div class="control-group">
                <label>Data Source</label>
                <select id="dataSource">
                    <option value="simulation">Simulation</option>
                    <option value="real_eeg" disabled>Real EEG Data</option>
                </select>
            </div>
            <div class="control-group" id="channelSelectGroup" style="display: none;">
                <label>EEG Channel</label>
                <select id="eegChannel"></select>
            </div>
            <div class="control-group">
                <label>Wave Propagation Speed</label>
                <input type="range" id="waveSpeed" min="0.1" max="5.0" step="0.1" value="1.0">
            </div>
            <div class="control-group">
                <label>Neural Excitation</label>
                <input type="range" id="excitation" min="0.01" max="0.1" step="0.01" value="0.03">
            </div>
            <div class="control-group">
                <label>Decay Rate</label>
                <input type="range" id="decay" min="0.9" max="0.999" step="0.001" value="0.995">
            </div>
            <div class="control-group">
                <label>Visualization Mode</label>
                <select id="vizMode">
                    <option value="waves">Neural Waves</option>
                    <option value="particles">Quantum Particles</option>
                    <option value="fields">Field Lines</option>
                    <option value="cortex">Ghost Cortex</option>
                </select>
            </div>
            <div class="control-group">
                <label>Frequency Band</label>
                <select id="freqBand">
                    <option value="theta-gamma">Theta-Gamma</option>
                    <option value="alpha-beta">Alpha-Beta</option>
                    <option value="delta-theta">Delta-Theta</option>
                    <option value="beta-gamma">Beta-Gamma</option>
                </select>
            </div>
            <button onclick="toggleSimulation()">START/STOP</button>
            <button onclick="resetSimulation()">RESET</button>
        </div>
        <div id="info">
            <div class="stats" id="status-line">Status: Ready</div>
            <div class="stats">Neural Activity: <span id="activity">0.0</span>%</div>
            <div class="stats">Wave Frequency: <span id="frequency">8.5</span> Hz</div>
            <div class="stats">Active Neurons: <span id="neurons">0</span></div>
            <div class="stats">Field Strength: <span id="fieldStrength">0.0</span></div>
        </div>
    </div>

    <script>
        // --- Global Scope ---
        let scene, camera, renderer, animationId;
        let neuralField = [], ghostCortex = [], waveParticles = [];
        let isRunning = false, time = 0, eegData = null, eegTime = 0;
        
        const gridSize = 48, gridExtent = 0.15, numParticles = 8000;
        const bands = {
            'theta-gamma': { slow: {low: 4, high: 8}, fast: {low: 30, high: 50} },
            'alpha-beta': { slow: {low: 8, high: 13}, fast: {low: 13, high: 30} },
            'delta-theta': { slow: {low: 1, high: 4}, fast: {low: 4, high: 8} },
            'beta-gamma': { slow: {low: 13, high: 30}, fast: {low: 30, high: 50} }
        };

        // --- Core 3D and Animation ---
        function init() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000000, 0.1, 1.5);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 1000);
            camera.position.set(0.3, 0.3, 0.3);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 0);
            
            container.appendChild(renderer.domElement);
            
            const ambientLight = new THREE.AmbientLight(0x002244, 0.3);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0x00ffaa, 1, 2);
            pointLight.position.set(0, 0.5, 0.5);
            scene.add(pointLight);
            
            initializeNeuralField();
            initializeGhostCortex();
            initializeWaveParticles();
            setupEventListeners();
            
            animate();
        }

        function animate() {
            animationId = requestAnimationFrame(animate);
            if (isRunning) {
                time += 0.016; // ~60fps
                simulateNeuralActivity();
            }
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Simulation Logic ---
        function simulateNeuralActivity() {
            const dataSource = document.getElementById('dataSource').value;
            if (dataSource === 'real_eeg' && eegData) {
                simulateFromRealEEG();
            } else {
                simulateFromInternalModel();
            }
        }

        function simulateFromRealEEG() {
            if (!eegData || !isRunning) return;
            const channelIndex = parseInt(document.getElementById('eegChannel').value);
            const freqBandName = document.getElementById('freqBand').value;
            const band = bands[freqBandName];
            const channelData = eegData.data[channelIndex];
            const sampleRate = eegData.sampleRate;
            const windowSize = Math.floor(2 * sampleRate);
            const startSample = Math.floor(eegTime * sampleRate);
            if (startSample + windowSize > channelData.length) { eegTime = 0; return; }

            const signalChunk = channelData.slice(startSample, startSample + windowSize);
            const { phase, amplitude } = getPhaseAndAmplitude(signalChunk, band.slow, band.fast, sampleRate);
            if (!phase || !amplitude) return;

            const maxAmp = Math.max(...amplitude, 1e-9);
            updateNeuralField( (neuron, index) => {
                const signalIndex = Math.floor((neuron.position.x + gridExtent/2) / gridExtent * (phase.length - 1));
                const slowPhase = phase[signalIndex];
                const fastAmplitude = amplitude[signalIndex] / maxAmp;
                return slowPhase * fastAmplitude;
            });
            eegTime += 1 / 60;
        }
        
        function simulateFromInternalModel() {
            const waveSpeed = parseFloat(document.getElementById('waveSpeed').value);
            const freqBandName = document.getElementById('freqBand').value;
            const band = bands[freqBandName];
            const slowFreq = (band.slow.low + band.slow.high) / 2;
            const fastFreq = (band.fast.low + band.fast.high) / 2;
            updateNeuralField((neuron, index) => {
                const slowPhase = Math.sin(time * slowFreq + neuron.phase);
                const fastAmplitude = Math.abs(Math.sin(time * fastFreq * waveSpeed));
                const centerDistance = neuron.position.length();
                return Math.exp(-centerDistance * 10) * slowPhase * fastAmplitude;
            });
        }

        function updateNeuralField(fieldStrengthFn) {
            const excitation = parseFloat(document.getElementById('excitation').value);
            const decay = parseFloat(document.getElementById('decay').value);
            const vizMode = document.getElementById('vizMode').value;
            let totalActivity = 0, activeNeurons = 0, maxFieldStrength = 0;

            neuralField.forEach((neuron, index) => {
                const fieldStrength = fieldStrengthFn(neuron, index);
                neuron.activity = neuron.activity * decay + fieldStrength * excitation;
                neuron.activity = Math.max(0, Math.min(1, neuron.activity));
                if (vizMode === 'waves' || vizMode === 'cortex') {
                    neuron.mesh.material.opacity = Math.max(0, neuron.activity);
                    neuron.mesh.material.color.setHSL(0.3 - (neuron.activity * 0.3), 1, 0.5);
                }
                totalActivity += neuron.activity;
                if (neuron.activity > 0.1) activeNeurons++;
                maxFieldStrength = Math.max(maxFieldStrength, neuron.activity);
            });
            
            ghostCortex.forEach(neuron => {
                const nearbyActivity = neuralField.filter(n => n.position.distanceTo(neuron.mesh.position) < 0.03).reduce((sum, n) => sum + n.activity, 0);
                neuron.activity = neuron.activity * 0.98 + nearbyActivity * 0.02;
                neuron.mesh.scale.setScalar(1 + neuron.activity * 2);
                neuron.mesh.material.opacity = Math.min(1, neuron.activity * 2);
            });
            
            waveParticles.visible = vizMode === 'particles' || vizMode === 'fields';
            if (waveParticles.visible) {
                 waveParticles.material.uniforms.time.value = time;
            }
            
            document.getElementById('activity').textContent = (totalActivity / neuralField.length * 100).toFixed(1);
            const band = bands[document.getElementById('freqBand').value];
            document.getElementById('frequency').textContent = `${((band.slow.low + band.slow.high) / 2).toFixed(1)} Hz`;
            document.getElementById('neurons').textContent = activeNeurons;
            document.getElementById('fieldStrength').textContent = maxFieldStrength.toFixed(2);
        }

        // --- Event Handlers & UI ---
        function setupEventListeners() {
            window.addEventListener('resize', onWindowResize);
            document.getElementById('fileInput').addEventListener('change', handleFileLoad);
            document.getElementById('dataSource').addEventListener('change', e => {
                const isRealEEG = e.target.value === 'real_eeg';
                document.getElementById('channelSelectGroup').style.display = isRealEEG ? 'block' : 'none';
                document.getElementById('subtitle').textContent = isRealEEG ? '(Real EEG Data)' : '(Simulation Mode)';
                resetSimulation();
            });
            let mouseDown = false, mouseX = 0, mouseY = 0;
            renderer.domElement.addEventListener('mousedown', e => { mouseDown = true; mouseX = e.clientX; mouseY = e.clientY; });
            renderer.domElement.addEventListener('mouseup', () => { mouseDown = false; });
            renderer.domElement.addEventListener('mousemove', e => {
                if (!mouseDown) return;
                const deltaX = e.clientX - mouseX, deltaY = e.clientY - mouseY;
                const spherical = new THREE.Spherical().setFromVector3(camera.position);
                spherical.theta -= deltaX * .01;
                spherical.phi -= deltaY * .01;
                spherical.phi = Math.max(.1, Math.min(Math.PI - .1, spherical.phi));
                camera.position.setFromSpherical(spherical);
                camera.lookAt(0, 0, 0);
                mouseX = e.clientX;
                mouseY = e.clientY;
            });
        }
        
        function toggleSimulation() { isRunning = !isRunning; }
        function resetSimulation() {
            time = 0; eegTime = 0;
            neuralField.forEach(n => { n.activity = 0; n.mesh.material.opacity = 0; });
            ghostCortex.forEach(n => { n.activity = 0; n.mesh.scale.setScalar(1); n.mesh.material.opacity = 0.7; });
        }
        
        function handleFileLoad(event) {
            const file = event.target.files[0];
            if (!file) return;
            document.getElementById('status-line').textContent = `Status: Loading ${file.name}...`;
            const reader = new FileReader();
            reader.onload = e => {
                try {
                    eegData = parseEDF(e.target.result);
                    document.getElementById('status-line').textContent = `Status: Loaded ${file.name}`;
                    document.getElementById('fileInputLabel').textContent = `âœ… ${file.name}`;
                    populateChannelSelector();
                    document.getElementById('dataSource').querySelector('[value="real_eeg"]').disabled = false;
                } catch (err) {
                    document.getElementById('status-line').textContent = `Error: ${err.message}`;
                }
            };
            reader.readAsArrayBuffer(file);
        }

        function populateChannelSelector() {
            const selector = document.getElementById('eegChannel');
            selector.innerHTML = '';
            eegData.channels.forEach((channel, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = channel;
                selector.appendChild(option);
            });
        }

        // --- Signal Processing Functions ---
        function parseEDF(buffer) {
            const view = new DataView(buffer);
            const decoder = new TextDecoder('ascii');
            const header = {
                version: decoder.decode(buffer.slice(0, 8)).trim(),
                headerBytes: parseInt(decoder.decode(buffer.slice(184, 192)).trim()),
                numRecords: parseInt(decoder.decode(buffer.slice(236, 244)).trim()),
                recordDuration: parseFloat(decoder.decode(buffer.slice(244, 252)).trim()),
                numChannels: parseInt(decoder.decode(buffer.slice(252, 256)).trim())
            };
            const ns = header.numChannels;
            if (ns <= 0 || ns > 1024) throw new Error("Invalid number of channels.");

            const channelInfo = Array.from({ length: ns }, (_, i) => ({
                label: decoder.decode(buffer.slice(256 + i * 16, 256 + (i + 1) * 16)).trim(),
                samplesPerRecord: parseInt(decoder.decode(buffer.slice(256 + ns * 216 + i * 8, 256 + ns * 216 + (i + 1) * 8)).trim()),
                pMin: parseFloat(decoder.decode(buffer.slice(256 + ns * 104 + i * 8, 256 + ns * 104 + (i + 1) * 8)).trim()),
                pMax: parseFloat(decoder.decode(buffer.slice(256 + ns * 112 + i * 8, 256 + ns * 112 + (i + 1) * 8)).trim()),
                dMin: parseInt(decoder.decode(buffer.slice(256 + ns * 120 + i * 8, 256 + ns * 120 + (i + 1) * 8)).trim()),
                dMax: parseInt(decoder.decode(buffer.slice(256 + ns * 128 + i * 8, 256 + ns * 128 + (i + 1) * 8)).trim())
            }));
            const sampleRate = channelInfo[0].samplesPerRecord / header.recordDuration;
            const totalSamples = header.numRecords * channelInfo[0].samplesPerRecord;
            const data = channelInfo.map(() => new Float32Array(totalSamples));
            let dataOffset = header.headerBytes;

            for (let r = 0; r < header.numRecords; r++) {
                for (let ch = 0; ch < ns; ch++) {
                    const info = channelInfo[ch];
                    const scale = (info.pMax - info.pMin) / (info.dMax - info.dMin);
                    if (!isFinite(scale)) continue;
                    const dc = info.pMin - scale * info.dMin;
                    const startIdx = r * info.samplesPerRecord;
                    let channelOffset = dataOffset;
                    for (let prevCh = 0; prevCh < ch; prevCh++) {
                        channelOffset += channelInfo[prevCh].samplesPerRecord * 2;
                    }
                    for (let s = 0; s < info.samplesPerRecord; s++) {
                        data[ch][startIdx + s] = view.getInt16(channelOffset + s * 2, true) * scale + dc;
                    }
                }
                dataOffset += channelInfo.reduce((sum, ch) => sum + ch.samplesPerRecord * 2, 0);
            }
            return { channels: channelInfo.map(c => c.label), sampleRate, data };
        }
        function iirFilter(data, cutoff, type = 'low') {
            const rc = 1.0 / (2.0 * Math.PI * cutoff);
            const alpha = 1.0 / (1.0 + rc);
            const filtered = new Float32Array(data.length);
            let last = 0;
            for (let i = 0; i < data.length; i++) {
                last += alpha * (data[i] - last);
                filtered[i] = last;
            }
            if (type === 'high') { for (let i = 0; i < data.length; i++) { filtered[i] = data[i] - filtered[i]; } }
            return filtered;
        }
        function butterworthBandpass(data, low, high, sampleRate) {
            const lowpass = iirFilter(data, high / (sampleRate / 2));
            return iirFilter(lowpass, low / (sampleRate / 2), 'high');
        }
        function getPhaseAndAmplitude(signal, phaseBand, ampBand, sampleRate) {
            const phaseFiltered = butterworthBandpass(signal, phaseBand.low, phaseBand.high, sampleRate);
            const ampFiltered = butterworthBandpass(signal, ampBand.low, ampBand.high, sampleRate);
            const n = signal.length;
            const phase = new Float32Array(n);
            const ampEnvelope = new Float32Array(n);
            for (let i = 1; i < n - 1; i++) {
                const imag_phase = (phaseFiltered[i + 1] - phaseFiltered[i - 1]) / 2;
                phase[i] = Math.atan2(imag_phase, phaseFiltered[i]);
                const imag_amp = (ampFiltered[i + 1] - ampFiltered[i - 1]) / 2;
                ampEnvelope[i] = Math.sqrt(ampFiltered[i] * ampFiltered[i] + imag_amp * imag_amp);
            }
            return { phase, amplitude: iirFilter(ampEnvelope, 10 / (sampleRate / 2)) };
        }

        // --- Object Initialization ---
        function initializeNeuralField(){const geometry=new THREE.SphereGeometry(.002,8,6);for(let i=0;i<gridSize;i++)for(let j=0;j<gridSize;j++)for(let k=0;k<gridSize;k++){const x=(i/(gridSize-1)-.5)*gridExtent,y=(j/(gridSize-1)-.5)*gridExtent,z=(k/(gridSize-1)-.5)*gridExtent,material=new THREE.MeshPhongMaterial({color:16755200,transparent:!0,opacity:0}),mesh=new THREE.Mesh(geometry,material);mesh.position.set(x,y,z),scene.add(mesh),neuralField.push({mesh:mesh,position:new THREE.Vector3(x,y,z),activity:0,phase:2*Math.random()*Math.PI})}}
        function initializeGhostCortex(){const cortexGeometry=new THREE.SphereGeometry(.06,32,32),cortexMaterial=new THREE.MeshPhongMaterial({color:17510,transparent:!0,opacity:.1,wireframe:!0}),cortexMesh=new THREE.Mesh(cortexGeometry,cortexMaterial);scene.add(cortexMesh);for(let i=0;i<200;i++){const theta=2*Math.random()*Math.PI,phi=Math.random()*Math.PI,r=.04+Math.random()*.04,x=r*Math.sin(phi)*Math.cos(theta),y=r*Math.sin(phi)*Math.sin(theta),z=r*Math.cos(phi),neuronGeometry=new THREE.SphereGeometry(.001,6,6),neuronMaterial=new THREE.MeshPhongMaterial({color:43775,transparent:!0,opacity:.7}),neuron=new THREE.Mesh(neuronGeometry,neuronMaterial);neuron.position.set(x,y,z),scene.add(neuron),ghostCortex.push({mesh:neuron,activity:0,connections:[]})}}
        function initializeWaveParticles(){const particleGeometry=new THREE.BufferGeometry,positions=new Float32Array(24e3),colors=new Float32Array(24e3),sizes=new Float32Array(8e3);for(let i=0;i<8e3;i++)positions[3*i]=(Math.random()-.5)*.3,positions[3*i+1]=(Math.random()-.5)*.3,positions[3*i+2]=(Math.random()-.5)*.3,colors[3*i]=0,colors[3*i+1]=1,colors[3*i+2]=.7,sizes[i]=2*Math.random()+1;particleGeometry.setAttribute("position",new THREE.BufferAttribute(positions,3)),particleGeometry.setAttribute("color",new THREE.BufferAttribute(colors,3)),particleGeometry.setAttribute("size",new THREE.BufferAttribute(sizes,1));const particleMaterial=new THREE.ShaderMaterial({uniforms:{time:{value:0}},vertexShader:"attribute float size;varying vec3 vColor;uniform float time;void main(){vColor=color;vec4 mvPosition=modelViewMatrix*vec4(position,1.);gl_PointSize=size*(300./ -mvPosition.z)*(1.+.5*sin(time*10.+position.x*50.));gl_Position=projectionMatrix*mvPosition;}",fragmentShader:"varying vec3 vColor;void main(){float distanceToCenter=distance(gl_PointCoord,vec2(.5));float alpha=1.-smoothstep(0.,.5,distanceToCenter);gl_FragColor=vec4(vColor,alpha*.8);}",transparent:!0,vertexColors:!0}),particles=new THREE.Points(particleGeometry,particleMaterial);scene.add(particles),waveParticles=particles}
        
        // --- Start Application ---
        init();
    </script>
</body>
</html>